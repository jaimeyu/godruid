// Code generated by go-swagger; DO NOT EDIT.

package swagmodels

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// AggregationConfig The necessary request parameters for the metric api call
// swagger:model AggregationConfig
type AggregationConfig struct {

	// The aggregation function to be used against the metrics filtered-in for the query
	// Required: true
	// Enum: [min max avg]
	Aggregation *string `json:"aggregation"`

	// An array of metric dimensions that filter-in metrics that adhere to those dimensions. Refer to the DimensionFilter object for further information
	Dimensions DimensionFilter `json:"dimensions,omitempty"`

	// The granularity for timeseries in ISO-8601 duration format, or ALL
	Granularity string `json:"granularity,omitempty"`

	// Time boundary for the metrics under consideration using the ISO-8601 standard
	// Required: true
	Interval *string `json:"interval"`

	// An object that allows filtering on arbitrary metadata criteria and their values. This attribute cannot be used if the monitoredObjects attribute is also present in the request. Refer to the MetaFilter object for additional details
	Meta MetaFilter `json:"meta,omitempty"`

	// An array of identifiers that filter-in specifically identified metrics.
	// Required: true
	Metrics []*MetricIdentifierFilter `json:"metrics"`

	// An optional array of monitored objects that we want to retrieve specific aggregations against. This attribute cannot be used if the meta attribute is also present in the request.
	MonitoredObjects []string `json:"monitoredObjects,omitempty"`

	// Query timeout in milliseconds
	Timeout int64 `json:"timeout,omitempty"`
}

// Validate validates this aggregation config
func (m *AggregationConfig) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAggregation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDimensions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInterval(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMeta(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMetrics(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var aggregationConfigTypeAggregationPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["min","max","avg"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		aggregationConfigTypeAggregationPropEnum = append(aggregationConfigTypeAggregationPropEnum, v)
	}
}

const (

	// AggregationConfigAggregationMin captures enum value "min"
	AggregationConfigAggregationMin string = "min"

	// AggregationConfigAggregationMax captures enum value "max"
	AggregationConfigAggregationMax string = "max"

	// AggregationConfigAggregationAvg captures enum value "avg"
	AggregationConfigAggregationAvg string = "avg"
)

// prop value enum
func (m *AggregationConfig) validateAggregationEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, aggregationConfigTypeAggregationPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *AggregationConfig) validateAggregation(formats strfmt.Registry) error {

	if err := validate.Required("aggregation", "body", m.Aggregation); err != nil {
		return err
	}

	// value enum
	if err := m.validateAggregationEnum("aggregation", "body", *m.Aggregation); err != nil {
		return err
	}

	return nil
}

func (m *AggregationConfig) validateDimensions(formats strfmt.Registry) error {

	if swag.IsZero(m.Dimensions) { // not required
		return nil
	}

	if err := m.Dimensions.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("dimensions")
		}
		return err
	}

	return nil
}

func (m *AggregationConfig) validateInterval(formats strfmt.Registry) error {

	if err := validate.Required("interval", "body", m.Interval); err != nil {
		return err
	}

	return nil
}

func (m *AggregationConfig) validateMeta(formats strfmt.Registry) error {

	if swag.IsZero(m.Meta) { // not required
		return nil
	}

	if err := m.Meta.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("meta")
		}
		return err
	}

	return nil
}

func (m *AggregationConfig) validateMetrics(formats strfmt.Registry) error {

	if err := validate.Required("metrics", "body", m.Metrics); err != nil {
		return err
	}

	for i := 0; i < len(m.Metrics); i++ {
		if swag.IsZero(m.Metrics[i]) { // not required
			continue
		}

		if m.Metrics[i] != nil {
			if err := m.Metrics[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("metrics" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *AggregationConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AggregationConfig) UnmarshalBinary(b []byte) error {
	var res AggregationConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
